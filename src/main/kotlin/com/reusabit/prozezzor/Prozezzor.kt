/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.reusabit.prozezzor

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.UsageError
import com.github.ajalt.clikt.parameters.options.OptionWithValues
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import java.io.File


fun <AllT, EachT, ValueT> OptionWithValues<AllT, EachT, ValueT>.chainIf(
  condition: Boolean,
  action: OptionWithValues<AllT, EachT, ValueT>.() -> OptionWithValues<out AllT, out EachT, out ValueT>
): OptionWithValues<out AllT, out EachT, out ValueT> {
  return if (condition) this.action()
  else this
}

class Prozezzor(
  val inputDirDefault: String? = null,
  val outputFileNameDefault: String = "prozezzor-output.xlsx",
  val outputDirDefault: String? = null,
) : CliktCommand() {
  val gui by option("-g", "--gui", help = "Display a GUI. Mutually exclusive of --interactive.").flag()

  val interactive by option(
    "-i",
    "--interactive",
    help = "CLI mode, prompt for missing values. Mutually exclusive of --gui."
  )
  .flag("-I", "--non-interactive", default = false)

  val inputDir by option(
    "-d",
    "--input-directory",
    help = "Location of the directory to process (e.g., the zoom chat archive directory)."
  )
  .chainIf(inputDirDefault != null) { this.default(inputDirDefault!!) }

  val outputFileName by option(
    "-o",
    "--output-file-name",
    help = "Output file name."
  )
  .default(outputFileNameDefault)

  val outputDirectory by option(
    "-O",
    "--output-directory",
    help = "Output directory. May only be specified when --output-file-name is a relative path. Must be an absolute path when running in --gui mode."
  )
  .chainIf(outputDirDefault != null) { this.default(outputDirDefault!!) }


  /**
   * Performs additional validation (e.g. mutual exclusions), throws errors to cause display
   * of usage information, and returns a simplified options representation.
   *
   * This only works if parse has been called.
   */
  fun toCommandLineOptions(): ProgramOptions.Builder {
    val mode = when {
      gui -> AppMode.GUI
      interactive -> AppMode.INTERACTIVE
      else -> AppMode.NON_INTERACTIVE
    }

    val outputFile = File(outputFileName)
    val outputDirectoryFile = outputDirectory?.let { File(it) }

    val outputFile0 = when {
      outputFile.isAbsolute -> outputFile
      else -> when {
        mode != AppMode.GUI -> outputFile.absoluteFile
        else -> when {
          outputDirectoryFile == null -> throw UsageError("The program is in --gui mode, --output-directory is not provided, and unable to determine a viable default.")
          else -> when {
            !outputDirectoryFile.isAbsolute -> throw UsageError("The program is in --gui mode and --output-directory [$outputDirectoryFile] is not an absolute path.")
            !outputDirectoryFile.isDirectory -> throw UsageError("The --output-directory [$outputDirectoryFile] is not a directory.")
            else -> outputDirectoryFile.resolve(outputFile)
          }
        }
      }
    }

    //println("inputDir = [$inputDir]")
    if (mode == AppMode.NON_INTERACTIVE) {
      if (inputDir == null) {
        throw UsageError("--input-directory is required if in non-interactive mode and a default cannot be determined")
      }
    }

    return ProgramOptions.Builder(mode = mode, inputDir = File(inputDir), outputFile = outputFile0)
  }

  override fun run() {}
}

fun main(argv: Array<String>) {
  val prozezzor = Prozezzor(
    inputDirDefault = determineInputDirDefault(),
    outputDirDefault = determineOutputDirDefault()
  )
  //argv.forEachIndexed { i, arg ->
  //  println("arg[$i]=$arg")
  //}
  prozezzor.main(argv)
  val programOptions = prozezzor.toCommandLineOptions()

  if (programOptions.mode == AppMode.GUI) {
    doGui(programOptions)
    return
  }

  //println("options: $programOptions")

  val programOptions0 = when {
    programOptions.mode == AppMode.NON_INTERACTIVE -> programOptions
    else -> doInteractivePrompts(programOptions)
  }

  //println("options: $programOptions0")

  doProcessing(programOptions0.build())
}



fun doInteractivePrompts(programOptions: ProgramOptions.Builder): ProgramOptions.Builder {
  throw NotImplementedError("Interactive prompts not implemented")
}
